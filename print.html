<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A guide to Rust for Kotlin developers</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="This book should help experienced Kotlin developers to quickly get up to speed with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics_syntax.html"><strong aria-hidden="true">1.1.</strong> Syntax differences</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">1.2.</strong> Macros</a></li><li class="chapter-item expanded "><a href="basics_primitives.html"><strong aria-hidden="true">1.3.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basics_error.html"><strong aria-hidden="true">1.4.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">2.</strong> Types and variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types_mutability.html"><strong aria-hidden="true">2.1.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="types_strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="types_commmon.html"><strong aria-hidden="true">2.3.</strong> Common types</a></li><li class="chapter-item expanded "><a href="types_constants.html"><strong aria-hidden="true">2.4.</strong> Constants</a></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.</strong> References</a></li><li class="chapter-item expanded "><a href="borrowing.html"><strong aria-hidden="true">4.</strong> Borrowing and Ownership</a></li><li class="chapter-item expanded "><a href="classes.html"><strong aria-hidden="true">5.</strong> Classes, or the lack there of</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes_deriving.html"><strong aria-hidden="true">5.1.</strong> Deriving and implementing</a></li><li class="chapter-item expanded "><a href="classes_default.html"><strong aria-hidden="true">5.2.</strong> Default</a></li></ol></li><li class="chapter-item expanded "><a href="methods.html"><strong aria-hidden="true">6.</strong> Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="methods_self.html"><strong aria-hidden="true">6.1.</strong> this/self</a></li><li class="chapter-item expanded "><a href="methods_functional.html"><strong aria-hidden="true">6.2.</strong> Functional Programming</a></li></ol></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules_directories.html"><strong aria-hidden="true">7.1.</strong> Directories</a></li></ol></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">8.</strong> Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates_adding.html"><strong aria-hidden="true">8.1.</strong> Adding crates</a></li><li class="chapter-item expanded "><a href="crates_standard.html"><strong aria-hidden="true">8.2.</strong> Not in standard</a></li><li class="chapter-item expanded "><a href="crates_common.html"><strong aria-hidden="true">8.3.</strong> Common crates</a></li></ol></li><li class="chapter-item expanded "><a href="result.html"><strong aria-hidden="true">9.</strong> Result, Option and Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="result_exception.html"><strong aria-hidden="true">9.1.</strong> Result and exceptions</a></li><li class="chapter-item expanded "><a href="result_option.html"><strong aria-hidden="true">9.2.</strong> Option and nulls</a></li></ol></li><li class="chapter-item expanded "><a href="creating_macros.html"><strong aria-hidden="true">10.</strong> Creating macros</a></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">11.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">12.</strong> Testing</a></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">13.</strong> Cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cargo_tools.html"><strong aria-hidden="true">13.1.</strong> Tools</a></li></ol></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">14.</strong> Enums</a></li><li class="chapter-item expanded "><a href="tips.html"><strong aria-hidden="true">15.</strong> Tips and tricks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tips_iflet.html"><strong aria-hidden="true">15.1.</strong> if let</a></li><li class="chapter-item expanded "><a href="tips_refcount.html"><strong aria-hidden="true">15.2.</strong> Reference counting</a></li><li class="chapter-item expanded "><a href="tips_strings.html"><strong aria-hidden="true">15.3.</strong> Converting strings</a></li><li class="chapter-item expanded "><a href="tips_intmut.html"><strong aria-hidden="true">15.4.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="tips_enumiter.html"><strong aria-hidden="true">15.5.</strong> Indexed iteration</a></li><li class="chapter-item expanded "><a href="tips_formatting.html"><strong aria-hidden="true">15.6.</strong> Formatting strings</a></li><li class="chapter-item expanded "><a href="tips_crates.html"><strong aria-hidden="true">15.7.</strong> For crates</a></li></ol></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">16.</strong> Common bugs/issues</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">17.</strong> Architecture</a></li><li class="chapter-item expanded affix "><a href="resources.html">Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A guide to Rust for Kotlin developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-guide-to-rust-for-kotlin-developers"><a class="header" href="#a-guide-to-rust-for-kotlin-developers">A guide to Rust for Kotlin developers</a></h1>
<p>This guide should help developers experienced with Kotlin quickly and easily learn the basics of Rust by comparing the major differences but also how the languages, by the nature of them both being modern languages, have quite a few similar features.</p>
<p>This book is a summary of the official Rust books, as well as forum threads, GitHub issues, and StackOverflow posts I've read and testing I've done.
Please also read the following books for a much more complete understanding of Rust:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>The official docs (often called the rust book or just the book in discussions)</td><td><a href="https://doc.rust-lang.org/stable/book">Link</a></td></tr>
<tr><td>A collection of examples for common patterns and tasks</td><td><a href="https://doc.rust-lang.org/stable/rust-by-example">Link</a></td></tr>
<tr><td>Guide for Cargo (see also the <a href="./cargo.html">Cargo chapter</a>)</td><td><a href="https://doc.rust-lang.org/cargo/">Link</a></td></tr>
</tbody></table>
</div>
<p>A lot of things you already know are going to be re-explained in this guide for two reasons:</p>
<ol>
<li>as a refresher and just to make your understanding is correct</li>
<li>to help explain and draw out differences between the languages; Rust is designed so that the compiler can guarantee some level of correctness in regards to variable access and destruction, and as such it will not compile code it can't predict.</li>
</ol>
<p>Some of the code samples have Ferris on them:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>This code panics!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>This code block contains unsafe code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>This code does not produce the desired behavior.</td></tr>
</tbody></table>
</div>
<p>(taken from the official book)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>To start with Rust you'll the compiler, go to <a href="https://rustup.rs/">rustup.rs</a> and follow the instructions.</p>
<p>Then I recommend installing and using Intellij CLion as you're already familiar with Intellij IDEs, otherwise you can use VSCode.</p>
<h3 id="command-line-basics"><a class="header" href="#command-line-basics">Command line basics</a></h3>
<p>Rust is controlled by it's package manager <code>cargo</code></p>
<p>To run your program execute <code>cargo run</code></p>
<p>To test it's <code>cargo test</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-differences"><a class="header" href="#syntax-differences">Syntax differences</a></h1>
<p>In Rust...</p>
<ul>
<li>lines have to end with a semicolon, except if it's an implicit return value (like in Kotlin lambdas).</li>
<li>methods parameters can not be variadic, named or have default values.</li>
<li>method overloading is not supported.</li>
<li>the naming scheme is <code>snake_case</code> for methods, variables and files; and <code>CamelCase</code> for Traits, Structs, Impls and Enums.</li>
<li>annotations are written like <code>#[Example]</code> instead of <code>@Example</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Rust uses macros a lot as they provide ways to shortened code, and provide variadic and optional parameters, and overloaded methods. Macros are invoked by the macro name then an exclamation mark, i.e. <code>example!</code>.</p>
<p>Macros can be used like functions <code>example!()</code> but anything can follow the exclamation mark as macros are very powerful, for example:</p>
<pre><code class="language-rust ignore">println!(&quot;Hello World&quot;);

let list = vec![1, 2, 3];

let foo = dsl! {
	init_with_default
	config = bar
}

//At compile time this will invoke the example macro with Foo as the parameter
#[Example]
struct Foo {

}</code></pre>
<p>The annotation macros will generate code for Structs like in Kotlin.</p>
<p>Macros can generate Rust code at compile time or run and return a result at runtime like a method. </p>
<p>Most programs don't need their own macros but will often use ones from std or crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives"><a class="header" href="#primitives">Primitives</a></h1>
<p>In Kotlin there are few commonly used primitive types:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th style="text-align: center">Bits</th><th>Type</th></tr></thead><tbody>
<tr><td>Byte</td><td style="text-align: center">8</td><td>Integer</td></tr>
<tr><td>Int</td><td style="text-align: center">32</td><td>Integer</td></tr>
<tr><td>Long</td><td style="text-align: center">64</td><td>Integer</td></tr>
<tr><td>Float</td><td style="text-align: center">32</td><td>Floating Point</td></tr>
<tr><td>Double</td><td style="text-align: center">64</td><td>Floating Point</td></tr>
<tr><td>Char</td><td style="text-align: center">16</td><td>UTF-16 Character</td></tr>
<tr><td>Boolean</td><td style="text-align: center">N/A</td><td>Boolean</td></tr>
</tbody></table>
</div>
<p>In Kotlin the Integer types are signed but there unsigned versions, i.e UByte.</p>
<p>Rust uses a prefix followed by the bit size to create a number type (e.g. i32 meaning a 32 bit signed integer), these are the prefixes:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Character</th><th>Type</th></tr></thead><tbody>
<tr><td style="text-align: center">i</td><td>Signed Integer</td></tr>
<tr><td style="text-align: center">u</td><td>Unsigned Integer</td></tr>
<tr><td style="text-align: center">f</td><td>Floating Point</td></tr>
</tbody></table>
</div>
<p>Floating points are 32 and 64 bit only but integers can be 8, 16, 32, 64, and 128 bits; there are also two architecture dependent sizes: <code>isize</code> and <code>usize</code> these are whatever the pointer size is for the CPU (for most new computers and phones that is 64 bits). 
As an example the equivalent to a Kotlin <code>Int</code> is <code>i32</code> and a <code>Double</code> is <code>f64</code>. </p>
<p><code>usize</code> is important as it's the primary number type: it's used in array, list and string formatting indexing and lengths/sizes of objects.</p>
<p>Suffixes for literals exist in Rust like in Kotlin but rather being for some types, suffixes exist for all primitives and they are the name of type, e.g. <code>3_i32</code> or <code>10.3f32</code>, the suffixes are only necessary if the compiler can not infer the type or if you want to specify it; also floating point numbers can be written without the 0, e.g. <code>1.</code></p>
<p>Booleans are the same in both languages except it's <code>bool</code> instead of <code>Boolean</code>.</p>
<p>Characters are different though, <code>char</code> in Rust is 4 bytes and can represent any Unicode scalar value. If you need to do text manipulation and need to handle any character outside of ASCII you will probably need to use these crates:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>unicode-segmentation</td><td>Used to iterate over grapheme clusters</td></tr>
<tr><td>unicode-normalization</td><td>Converts char + modifier into single character, this is vital if you need to compare Unicode strings</td></tr>
</tbody></table>
</div>
<p>See also the <a href="./types_strings.html">Strings chapter</a> for more information about how unicode is handled in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Rust has a generic error interface: <code>std::error::Error</code>, it's optionally may have a source error and/or backtrace. Instead of exceptions and try..catch the follow is used:</p>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">fun main() {
  try {
    openSocket()
    println(&quot;Worked&quot;)
  } catch (e: IOException) {
    println(&quot;Error: &quot; + e.message)
  }
}

</code></pre>
<p><strong>Rust</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::error::Error as StdError;
</span><span class="boring">type Error = Box&lt;dyn StdError&gt;;
</span>
fn main() {
	match open_socket() {
		Ok(()) =&gt; println!(&quot;Worked&quot;),
		Err(e) =&gt; println!(&quot;Error: {}&quot;, e)
	}
}

<span class="boring">fn open_socket() -&gt; Result&lt;(), Error&gt; { Ok(()) }</span></code></pre></pre>
<p>You can call <code>unwrap()</code> on a <code>Result</code> to get the success value or crash the app. To avoid repetitive code you can use <code>?</code> which will immediately return the error:</p>
<pre><code class="language-rust ignore">fn unwrap_example() {
	let foo = open().unwrap();
}

//the question mark operator is only valid in methods that return Result
fn better_example() -&gt; Result&lt;(), Error&gt; { 
	let bar = open()?;

	Ok(())
}</code></pre>
<p>Some crates errors aren't compatible with each other and so have to be converted to something before the error can be returned:</p>
<pre><code class="language-rust does_not_compile ignore">fn main() -&gt; Result&lt;(), Error&gt; { 
	let file = open_file()?; //Error type is IoError
	let socket = open_socket()?; //Error type is NetError

	Ok(())
}</code></pre>
<p>This example wouldn't compile because the size in memory of a return type must be known at compile time and <code>Error</code> is a trait (an <code>interface</code> in Kotlin). So it must be wrapped like so <code>Box&lt;dyn Error&gt;</code>, <code>Box</code> moves the value to the heap and is essentially a pointer, <code>dyn</code> just means the type is dynamically dispatched (i.e. a trait). (see https://doc.rust-lang.org/std/keyword.dyn.html)</p>
<ol>
<li>Create a wrapper type and implement it for all error types that you have to handle</li>
<li>Use <a href="https://github.com/yaahc/eyre">eyre</a></li>
</ol>
<p>I highly recommend anyhow for all apps, it automatically handles all error types and reduces boilerplate:</p>
<pre><code class="language-rust ignore">use eyre::Result; //import eyre Result and Error instead of std as needed

fn main() -&gt; Result&lt;()&gt; { //Result only has single parameter
	Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-and-variables"><a class="header" href="#types-and-variables">Types and variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>Because of the limitations imposed by the JVM in Kotlin variables are mutable or immutable sometimes based on type and sometimes by declaration. In Rust (and some other languages such as Swift) mutability is controlled via declaration:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() { 
	let foo: i32 = 1;     //immutable
	let mut bar: i32 = 2; //mutable
}</code></pre></pre>
<p>Immutable variables can't be referenced as mutable, so the following will not compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
	let foo: i32 = 1; 

	//This is invalid as the variable is immutable and so all 
	//references must be immutable as well
	change_ref(&amp;mut foo); 

	//This is fine as a copy of the value is passed into the 
	//method and only the copy is mutable
	change_val(foo); 
}

fn change_ref(value: &amp;mut i32) {
	*value += 1; 
}

fn change_val(value: mut i32) {
	value += 1;
}</code></pre>
<p>Note that unlike in Kotlin lists (and any other objects and their properties) in Rust can't be changed if the variable isn't marked as mutable, so the following will not compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
	let list = vec![1, 2, 3];

	list.push(4);
}</code></pre>
<p>See also
<a href="./tips_intmut.html">Interior mutability</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>In both Kotlin and Java, essentially, there is just one String type: String. Whether the text is hardcoded, from a file or user input the same class is used. Rust has two String types: String and str. A hardcoded string will be of type <code>&amp;'static str</code> and a string read from anywhere else maybe a <code>String</code> or <code>&amp;str</code> depending on what the method returns. They can be converted between themselves, in most circumstances.</p>
<p><code>String</code> is a pointer to a string in heap with a capacity, this means it can grow and can be mutable. A <code>&amp;str</code> is a char array and so has a fixed length.
If you attempt to slice a string so it would cause a Unicode character to be broken Rust will panic. Use the .chars() method to access each character independently. So to get the length of a string in bytes you use foo.len() and to get the number of characters you use foo.chars().count(). </p>
<p>Note that std Rust has limited supported for unicode and you may need to use crates to add missing features, this is because unicode changes regularly and the unicode table is quite large and has to be compiled into your program.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>unicode-segmentation</td><td>Used to iterate over grapheme clusters</td></tr>
<tr><td>unicode-normalization</td><td>Converts char + modifier into single character, this is vital if you need to compare Unicode strings</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="common-types"><a class="header" href="#common-types">Common types</a></h1>
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td><code>List&lt;T&gt;</code>, <code>MutableList&lt;T&gt;</code>, <code>ArrayList&lt;T&gt;</code></td><td><code>Vec&lt;T&gt;</code></td></tr>
<tr><td>Constructor</td><td><code>ArrayList(size)</code>, <code>ArrayList(collection)</code></td><td><code>Vec::new()</code>, <code>Vec::with_capacity(size)</code></td></tr>
<tr><td>Shorthand</td><td><code>listOf(items...)</code>, <code>mutableListOf(items...)</code>, <code>arrayListOf(items...)</code></td><td><code>vec![size; default]</code>, <code>vec![items...]</code></td></tr>
</tbody></table>
</div>
<h3 id="maps"><a class="header" href="#maps">Maps</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td><code>Map&lt;K, V&gt;</code>, <code>MutableMap&lt;K, V&gt;</code>, <code>HashMap&lt;K, V&gt;</code></td><td><code>HashMap&lt;K, V&gt;</code></td></tr>
<tr><td>Constructor</td><td><code>HashMap(size)</code>, <code>HashMap(map)</code></td><td><code>HashMap::new()</code></td></tr>
<tr><td>Shorthand</td><td><code>mapOf(items...)</code>, <code>mutableMapOf(items...)</code>, <code>hashMapOf(items...)</code></td><td>N/A <sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
</div>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td><code>Pair&lt;T1, T2&gt;</code>, <code>Triple&lt;T1, T2, T3&gt;</code></td><td><code>(T1, T2, ...)</code></td></tr>
<tr><td>Constructor</td><td><code>Pair(value1, value2)</code>, <code>Triple(value1, value2, value3)</code></td><td>N/A</td></tr>
<tr><td>Shorthand</td><td><code>value1 to value2</code></td><td><code>(value1, value2, ...)</code></td></tr>
</tbody></table>
</div>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td><code>Array&lt;T&gt;</code></td><td><code>[T]</code></td></tr>
<tr><td>Constructor</td><td><code>Array(size, builder_method)</code></td><td>N/A</td></tr>
<tr><td>Shorthand</td><td><code>arrayOf(items...)</code></td><td><code>[items...]</code></td></tr>
</tbody></table>
</div>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Crates such as <a href="https://github.com/bluss/maplit">maplit</a> do provide macros for this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>In Rust there are two types of constants <code>const</code> and <code>static</code>. <code>const</code> are immutable values hardcoded into the program. statics are optionally mutable values that are globally available. Using mutable statics is unsafe unless wrapped in thread safe structs such as <code>Arc</code> and <code>Mutex</code>. (See <a href="./concurrency.html">Concurrency</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const VERSION: u32 = 1;
static PROGRAM_NAME: &amp;'static str = &quot;Example&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Currently const and static values must be known at compile time. To get around this you can use the <a href="https://github.com/rust-lang-nursery/lazy-static.rs">lazy_static</a> crate, it works like <code>by lazy {}</code> in Kotlin:</p>
<pre><code class="language-rust ignore">use lazy_static::lazy_static;

lazy_static! {
	static ref A_MAP = HashMap::new();
}</code></pre>
<p>const values are inserted at compile time where ever they were used, and so if you make a a mutable constant every use will be it's own instance.</p>
<p>A method can be constant if it's all of it's internal are constant as well, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: usize = 1;
const BAR: usize = 2;

const RESULT: usize = add(FOO, BAR);

const fn add(lhs: usize, rhs: usize) -&gt; usize {
	lhs + rhs
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>All variables can be passed as a reference by prefixing with a <code>&amp;</code>, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let foo = 10; 
	print(foo); 
	print_ref(&amp;foo);
}

fn print(value: i32) { 
	//Passed by value so no need to deference
	example(value);
}

fn print_ref(value: &amp;i32) {
	//Dereferenced with *
	example(*value); 
}

fn example(value: i32) {
	//do something with value
}</code></pre></pre>
<p>Dereferencing a variable moves the value, so the value must implement <code>Copy</code>. See <a href="./classes_deriving.html">Deriving and implementing</a></p>
<p>For clarity:</p>
<div class="table-wrapper"><table><thead><tr><th>Symbols</th><th>Meaning</th></tr></thead><tbody>
<tr><td>&lt;No symbols&gt;</td><td>Value, immutable</td></tr>
<tr><td>mut</td><td>Value, mutable</td></tr>
<tr><td>&amp;</td><td>Reference, immutable</td></tr>
<tr><td>&amp;mut</td><td>Reference, mutable</td></tr>
<tr><td>*</td><td>Dereferenced</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-and-ownership"><a class="header" href="#borrowing-and-ownership">Borrowing and Ownership</a></h1>
<p>In Kotlin a variable exists, and is available, while in it’s scope. A global static variable is always available but a variable created in a method (unless returned) only exists during that instance of the methods execution. Rust is basically the same and generally you’ll be able to write code without having to think about the borrowing system, but sometimes you will have to deal with it.</p>
<p>This will not compile as <code>bar</code> has taken ownership of the data in <code>foo</code> and so <code>foo</code> can no longer be used:</p>
<pre><code class="language-rust does_not_compile ignore">let foo = String::from(&quot;Hello&quot;); 
let bar = foo;
println!(&quot;{}&quot;, foo);</code></pre>
<p>This will compile however as numbers have Copy implemented for them and so num2 automatically makes a copy of num1s data:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = 54;
let num2 = num1; 
println!(&quot;{}&quot;, num1);
<span class="boring">}</span></code></pre></pre>
<p>but this can be replicated for the string example by doing:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = String::from(&quot;Hello&quot;); 
let bar = foo.clone();
println!(&quot;{}&quot;, foo);
<span class="boring">}</span></code></pre></pre>
<p>This will only work when the type implemented Clone. Not all types support Clone as it may be impossible to copy it’s data, for example with network streams.
Ownership and borrowing apply to all methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let a = String::from(&quot;Hello&quot;); 
	let b = return_param(a);
	let c = length(b);
    println!(&quot;{}&quot;, c);
}

fn return_param(param: String) -&gt; String { 
	return param;
}

fn length(param: String) -&gt; usize {
	return param.len();
}</code></pre></pre>
<p>When main is executed both <code>a</code> and <code>b</code> are lost, length takes ownership of the string and it is dropped at the end of length, to keep <code>b</code> in memory either of the following changes could be made:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">let str = String::from(&quot;test&quot;);
</span><span class="boring">let _ref_len = length_ref(&amp;str);
</span><span class="boring">let (nstr, len) = length(str);
</span><span class="boring">println!(&quot;({},{})&quot;, nstr, len);
</span><span class="boring">}
</span>
fn length_ref(param: &amp;String) -&gt; usize {
	return param.len(); //not dereferenced:
	//because param is a reference len() will return it's result as a reference
	//and because usize implements Copy it will be automatically dereferenced
}

//or

fn length(param: String) -&gt; (String, usize) { 
	let len = param.len();
	return (param, len);
}</code></pre></pre>
<p>References are just pointers and so don’t take ownership but instead the value is borrowed, there are some rules around this for example only one mutable reference can exist at once. Because of this a potential helpful way to think about this is shared vs unique, you can as many read only references as you want shared around but when writeable only a single unique reference can exist (to avoid race conditions, etc).</p>
<p>Rust supports generics like Kotlin and they are expressed like this: <code>Vec&lt;Item&gt;</code>, occasionally you might see <code>Vec&lt;&amp;'a Item&gt;</code> the <code>'a</code> is a lifetime notation and these are used to guide the compiler as to how long references will be alive. The lifetime name doesn’t matter but the standard names are <code>'a</code>, <code>'b</code> and <code>'c</code>, except for <code>'static</code> which means the variable must always be available, i.e. a hardcoded value.</p>
<p>If a parameter has the lifetime <code>a</code> and a result also has the lifetime <code>a</code> like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
	contents: String
}

impl Foo {
	//like with generics the lifetime has to specified in advance with &lt;&gt;
	fn get_first&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str {
		&amp;self.contents[0..1]
	}
}
<span class="boring">}</span></code></pre></pre>
<p>then this is saying the instance of <code>Foo</code> must live as long as the reference returned by <code>get_first</code>.</p>
<p>However, in the example above the lifetimes aren't because the method has one parameter that is a reference and one result that is a reference and they share the same lifetime, so Rust will automatically assume the lifetime.</p>
<p>This would not compile:</p>
<pre><code class="language-rust does_not_compile ignore"><span class="boring">struct Foo {	contents: String }
</span>
<span class="boring">impl Foo {
</span><span class="boring">fn get_first&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str {&amp;self.contents[0..1]}
</span><span class="boring">}
</span>
fn main() {
	let result = get_char();
}

fn get_char() -&gt; &amp;str {
	let foo = Foo { contents: String::from(&quot;example&quot;) };
	let chr = foo.get_first();
	return chr;
}</code></pre>
<p>as there's no lifetime on the result of <code>get_char</code> and there can't be as <code>foo</code> is dropped at the end of <code>get_char</code> and so <code>chr</code> would be pointing to an invalid section of memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-or-the-lack-there-of"><a class="header" href="#classes-or-the-lack-there-of">Classes, or the lack there of</a></h1>
<p>In Kotlin has Classes, Abstract Classes, Interfaces, and extension methods. Rust has Traits, Structs, and Impls. </p>
<h4 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h4>
<ul>
<li>An interface can have methods but can not have variables with values, and may extend another Interface. It can be supplemented with extension methods or sub classed by other Classes, Abstract Classes or Interfaces.</li>
<li>A class can have variables and methods, and may extend a Class, an Abstract Class and/or Interface(s). It can be supplemented with extension methods or sub classed by other Classes or Abstract Classes.</li>
<li>An abstract class can have variables and methods, and may extend a Class, an Abstract Class and/or Interface(s). It can be supplemented with extension methods or sub classed by other Classes or Abstract Classes.</li>
</ul>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<ul>
<li>A trait is like an interface, it defines a list of methods that must be implemented. It can extend other traits, although this is rare.</li>
<li>A struct is the closest thing to a class but although it has a list of variables it does not have any methods. This can not extend anything.</li>
<li>An impl is a collection of methods either matching a Trait (like a Class implementing an Interface) or free form from a struct (like a Class), but Impl are not allowed to have variables and if implementing a Trait can not have methods that are not defined in the Trait. An Impl may be defined repeatedly.</li>
<li>trait and impl can used like extension Methods (although the syntax is closer to Swift than Kotlin).</li>
</ul>
<p>There is nothing like an abstract class in Rust.</p>
<p>Some Kotlin examples:</p>
<pre><code class="language-kotlin">interface ParentA {
	fun foo() //no method body, just an api
}

interface ParentB : ParentA { //includes methods from parent 
	fun bar() //no method body, just an api
}

class ClassFoo : ParentA { //includes methods from parent 
	var x = 0; //allowed to have variables with values 
	fun foo() {} //methods must be implemented
}

abstract class AbstractClassA: ParentA, ParentB {}

class ClassBar : AbstractClassA() {
	fun foo() {} //methods must be implemented 
	fun bar() {} //from all parents
	fun foobar() {} //can add new methods
}

fun ParentFoo.example1() {} //Adds method called example1 to all
//implementations and children of ParentA
</code></pre>
<p>Some Rust examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StructFoo { //variables only 
	x: i32
}

impl StructFoo {  //methods only, but can access 
	fn foo() {} //variables from Struct
}               //private methods allowed

trait TraitA { //API only 
	fn bar();
}

trait TraitC : TraitA {
	fn boo(); //anything implementing TraitC must implement TraitA separately
}

impl TraitA for StructFoo { //methods only, can not 
	fn bar() {}             //have methods not in the trait
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-and-implementing"><a class="header" href="#deriving-and-implementing">Deriving and implementing</a></h1>
<p>Let’s say you make a type: Person. It has a first name, last name, date of birth, and occupation. It has functions to get the whole name and their age.</p>
<pre><code class="language-rust ignore">use chrono::Date;
use chrono::offset::{*};

struct Person&lt;'a&gt; { 
	first_name: &amp;'a str, 
	last_name: &amp;'a str, 
	date_of_birth: Date&lt;Utc&gt;, 
	occupation: &amp;'a str
}

//Constructors
impl &lt;'a&gt; Person&lt;'a&gt; {
	//no self param means this is a static method 
	fn new(first_name: &amp;'a str,
		last_name: &amp;'a str,
		year: u32,
		month: u32,
		day: u32,
		occupation: &amp;'a str) -&gt; Person&lt;'a&gt; {
		return Person {
			first_name,
			last_name,
			date_of_birth: Utc.ymd(year as i32, month, day), 
			occupation
		}; 
	}
}

//Methods
impl &lt;'a&gt; Person&lt;'a&gt; {
	//self param means this is an instance method 
	//as it's a reference this method does not consume 
	//the object
	fn whole_name(&amp;self) -&gt; String {
		return format!(&quot;{} {}&quot;, self.first_name, self.last_name); 
	}

	fn age_in_years(&amp;self) -&gt; i32 {
		let weeks = Utc::today().signed_duration_since(self.date_of_birth).num_weeks();
		return (weeks / 52) as i32;
	} 

	//the self here isn't a reference so the object
	//is consumed by this method and won't exist
	//after this is method is called
	fn into_tuple(self) -&gt; (String, i32) {
		return (self.whole_name(), self.age_in_years());
	}
}

fn main() {
	//Double colon is for static methods
	let person = Person::new(&quot;John&quot;, &quot;Smith&quot;, 1988, 07, 10, &quot;Author&quot;);
	 
	//Period is for instance methods
	println!(&quot;{} is a {} who is {} years old.&quot;, 
		person.whole_name(), 
		person.occupation, 
		person.age_in_years());
}</code></pre>
<p>The <code>'a</code> lifetime tells Rust that the <code>&amp;str</code>s will be available as long as the parent <code>Person</code> is.
The sample uses the <code>chrono</code> crate, it is a simple to use and common date and time library. If we want to print the object we must implement the Display like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

<span class="boring">struct Person { 
</span><span class="boring">first_name: String, 
</span><span class="boring">last_name: String, 
</span><span class="boring">occupation: String
</span><span class="boring">}
</span>
impl fmt::Display for Person {
	fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
		return write!(f, &quot;({} {}, {})&quot;, 
			self.first_name, 
			self.last_name, 
			self.occupation);
	} 
}
<span class="boring">}</span></code></pre></pre>
<p>You can now write <code>println!(&quot;{}&quot;, person)</code>, there are many traits that can be implemented for any struct that’s part of your project.
To avoid boilerplate Rust can automatically derive some traits for structs like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Hash, Default)]
struct Foo {} 
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Trait</th><th>Use</th></tr></thead><tbody>
<tr><td>Debug</td><td>Automatically generates the equivalent of data classes toString(), use with {:?} instead of {}</td></tr>
<tr><td>Clone</td><td>Implements the clone() method on the struct</td></tr>
<tr><td>Copy</td><td>Allows structs to be cloned automatically instead of transferring ownership when assigned to new variable</td></tr>
<tr><td>PartialEq</td><td>Implements equality checking and enables use of the == and != operators on the struct</td></tr>
<tr><td>PartialOrd</td><td>Implements comparison and enables use of the &gt; and &lt; operators on the struct for types where the comparison may be impossible (e.g. floating numbers)</td></tr>
<tr><td>Eq</td><td>Marker trait (like Sync) meaning that all fields can be always and correctly compared, not valid for all types (e.g. floating numbers)</td></tr>
<tr><td>Ord</td><td>Same as PartialOrd but for types where comparison is always possible</td></tr>
<tr><td>Hash</td><td>Automatically generates the equivalent of data classes hashCode(), required to use the struct as key in HashMaps</td></tr>
<tr><td>Default</td><td>Implements a default value for all fields, see <a href="./classes_default.html">Default</a></td></tr>
</tbody></table>
</div>
<p>All of these require all the fields in the struct to implement the same traits. Numbers, strings, etc implement all the built in derivable types. As with <code>PartialEq</code> and <code>Eq</code> Rust often has two versions of a trait, one that is allowed to fail (and so will generally return <code>Result</code> or <code>Option</code>) and another that is not allowed to fail. In this case <code>Eq</code> will panic if something goes wrong, likewise there is <code>From</code> and <code>TryFrom</code> for converting structs, <code>From</code> will panic if it fails and <code>TryFrom</code> will return <code>Err</code> if it fails.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default"><a class="header" href="#default">Default</a></h1>
<p>If you implement a struct where all the fields have all implemented Default then you don’t have to write out every field when making a new instance of the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Default)]
struct Foo { 
	a: i32,
	b: i32,
	c: i32,
	d: String
}

fn main() {
	let foo = Foo::default();
	  
	//You can also supply some of the fields and leave the rest to Default:
	let foo2 = Foo { 
		b: 45,
		d: &quot;Foobar&quot;.to_string(), 
		..Foo::default()
	};
	
	//This is also the syntax for copying:
	let foo3 = Foo { 
		a: 10,
		..foo 
	};
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thisself"><a class="header" href="#thisself">this/self</a></h1>
<p>A method in a impl for a struct may have a param for the struct, it must always be the first parameter and does not have a name:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Meaning</th><th>Usage</th></tr></thead><tbody>
<tr><td>&lt;None&gt;</td><td>A static method (accessed via ::)</td><td>For constructors/builders or grouping methods</td></tr>
<tr><td>self</td><td>The object itself (this means unless the method returns Self it will dropped after this method)</td><td>Converting the object into another object</td></tr>
<tr><td>&amp;self</td><td>A immutable reference to itself</td><td>Getting a value or perform a action that doesn't effect this object</td></tr>
<tr><td>&amp;mut self</td><td>A mutable reference to itself</td><td>Setting a value or perform an action that changes internal values</td></tr>
</tbody></table>
</div>
<p>An example of naming conventions:</p>
<pre><code class="language-rust ignore">struct Foo {
	...
}

impl Foo {
	//Constructor: new()
	fn new() -&gt; Foo {}
}

impl Foo {
	//Getter: x()
	fn value(&amp;self) -&gt; i32]
	//Setter: set_x()
	fn set_value(&amp;mut self, value: i32) {}
	//Is/Has: is_x()
	fn is_empty(&amp;self) -&gt; bool {}
	//Clone and convert: as_x()
	fn as_bar(&amp;self) -&gt; Bar {}
	//Convert: into_x()
	fn into_another_object(self) -&gt; Bar {}
}</code></pre>
<p>See also <a href="https://rust-lang.github.io/api-guidelines/naming.html">https://rust-lang.github.io/api-guidelines/naming.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h1>
<p>Rust supports lambdas, the parameters are written comma separated in pipes and the body only requires curly braces if it goes over multiple lines:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let x = vec![1,2,3];
	let y: Vec&lt;usize&gt; = x.iter()
		.map(|it| it + 1)
		.collect();

<span class="boring">println!(&quot;{:?}&quot;, y);
</span><span class="boring">}</span></code></pre></pre>
<p>Unfortunately with Rust (like Dart) <code>map()</code>, etc return a Map object that has to be converted back into a list using <code>collect()</code></p>
<p>Rust also supports higher order functions:</p>
<pre><code class="language-rust ignore">fn foo(f: impl Fn(i32) -&gt; i32)
fn foo&lt;F&gt;(f: F) where F: Fn(i32) -&gt; i32 
fn bar(f: impl MutFn(String) -&gt; usize)</code></pre>
<p>Fn can not change external state</p>
<p>FnMut can change external state</p>
<p>FnOnce can change external state, but is only allowed to be called once</p>
<p>Box allows you to store values on the heap, this is sometimes necessary as the stack can only hold values with a known size (at compile time), as the Box is just a pointer it has a known size unlike, for example, lambdas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>When making a project in Rust you are required to have one file (for programs it’s <code>main.rs</code>, and <code>lib.rs</code> for libraries), it’s also the only file recognised by the compiler. To add a new file to your project you need to add the line (for a file named <code>new_file.rs</code>) to <code>main.rs</code> or <code>lib.rs</code>:</p>
<pre><code class="language-rust ignore">mod new_file;</code></pre>
<p>Using the following code base:</p>
<pre><code class="language-rust ignore">//main.rs
mod foo; //all Rust files must be referenced here for the compiler to find them 
mod bar;

use crate::bar::foobar;

fn main() { 
	foobar();
}
//foo.rs
pub fn public_method() {} 
fn private_method() {}

//bar.rs
use crate::foo::public_method; 
pub fn foobar() {}</code></pre>
<p>The foo module has two methods public_method and private_method. private_method is only accessible inside the foo module. The bar module imports the public_method method from the foo module.</p>
<p><code>crate</code> means this project, if using a third party library (for example <code>serde</code>) you would write <code>serde::foo::bar;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="directories"><a class="header" href="#directories">Directories</a></h1>
<p>When organising code it is common to group files in a directory. This requires a mod.rs file per directory, at minimum it must reference the other files in the directory to expose them to the compiler:</p>
<pre><code class="language-plaintext">project 
├ main.rs
├ foo.rs
└ bar 
  ├ mod.rs
  └ inner.rs

</code></pre>
<pre><code class="language-rust ignore">//main.rs
mod foo; 
mod bar;

//bar/mod.rs
mod inner;</code></pre>
<p>This would expose all files to the compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-crates"><a class="header" href="#adding-crates">Adding crates</a></h1>
<p>Third party libraries are called Crates (and are available from https://crates.io). To add a crate, for example Serde, add this line to Cargo.toml after the [dependencies] line:</p>
<pre><code class="language-toml">serde = &quot;1.0.0&quot;
</code></pre>
<p>You’ll still need to import the individual parts of the crate you want to use, for example:</p>
<pre><code class="language-rust ignore">use serde::json::Serialize;</code></pre>
<p><code>::Foo</code> means import just Foo</p>
<p><code>::{Foo, Bar}</code> means import Foo and Bar </p>
<p><code>::*</code> means import everything in the module.</p>
<p>You can rename when importing:</p>
<pre><code class="language-rust ignore">use example::Foo as Bar;</code></pre>
<p>Most of the massive crates have a prelude module that you should import, i.e.</p>
<pre><code class="language-rust ignore">use chrono::prelude::*</code></pre>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>Some crates have optional features, often these include macros or provide interop with other crates:</p>
<p><code>serde = &quot;1.0.0&quot;</code> can also be written as <code>serde = { version = &quot;1.0.0&quot; }</code>. To include a feature this gets expanded to <code>serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }</code>.</p>
<p>Some crates will have features that you almost always want:</p>
<div class="table-wrapper"><table><thead><tr><th>Crate</th><th>Feature(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>serde</code></td><td><code>derive</code></td><td>Adds macros to automatically serialize structs</td></tr>
<tr><td><code>chrono</code></td><td><code>serde</code></td><td>Allows <code>DateTime</code>, etc to be serialized by <code>serde</code></td></tr>
<tr><td><code>reqwest</code></td><td><code>json</code>, <code>gzip</code></td><td>Adds support for sending/received structs and adds automatic support for gzip</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="not-in-standard"><a class="header" href="#not-in-standard">Not in standard</a></h1>
<p>Some functionality built in to Java/Kotlin isn’t part of the Rust std lib and you’ll need to use these crates to add it:</p>
<div class="table-wrapper"><table><thead><tr><th>Functionality</th><th>Crate</th><th>Notes</th></tr></thead><tbody>
<tr><td>Random numbers</td><td>rand</td><td>Maintained by Rust team</td></tr>
<tr><td>Serialization</td><td>serde</td><td>Does XML, JSON, protobuf, etc</td></tr>
<tr><td>Lazy static variables</td><td>lazy_static</td><td></td></tr>
<tr><td>Regex</td><td>regex</td><td>Maintained by Rust team</td></tr>
<tr><td>Base64</td><td>base64</td><td></td></tr>
<tr><td>UUID</td><td>uuid</td><td></td></tr>
<tr><td>Enums</td><td>strum</td><td>Enum features variant names, properties, count, list, ordinal</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="common-crates"><a class="header" href="#common-crates">Common crates</a></h1>
<p>These crates are the closest equivalent to the commonly used Kotlin libraries:</p>
<div class="table-wrapper"><table><thead><tr><th>Kotlin</th><th>Rust</th><th>Notes</th></tr></thead><tbody>
<tr><td>GSON/Moshi</td><td><a href="https://serde.rs/">serde</a></td><td>Much more powerful and flexible than GSON</td></tr>
<tr><td>JodaTime</td><td><a href="https://github.com/chronotope/chrono">chrono</a></td><td>Essentially the same</td></tr>
<tr><td>JDBC</td><td><a href="https://github.com/diesel-rs/diesel">diesel</a></td><td>Works with multiple databases</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="result-option-and-exceptions"><a class="header" href="#result-option-and-exceptions">Result, Option and Exceptions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-exceptions"><a class="header" href="#result-and-exceptions">Result and exceptions</a></h1>
<p>Result&lt;V, E&gt; is used for when a method may fail, it can contain the result or an error. It is created via <code>Ok()</code> and <code>Err()</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get(idx: u32) -&gt; Result&lt;bool, usize&gt; {
	if idx &gt; 10 {
		Ok(true)
	} else if idx &gt; 20 {
		Ok(false)
	} else {
		Err(404)
	}
}

fn main() {
	let result = get(10);
	match result {
		Ok(item) =&gt; println!(&quot;{}&quot;, item),
		Err(e) =&gt; println!(&quot;{}&quot;, e)
	}
}</code></pre></pre>
<p>You can also do the equivalent of <code>var!!</code> with both Option and Result by using <code>var.unwrap()</code> and <code>var.expect(&quot;some message&quot;)</code>. Both methods will crash the app if it’s Err/None, expect() will also write the message to the console.</p>
<p>To avoid having to write unwrap() every time if you’re in a method that returns a Result you can just write <code>var?</code>, if <code>var</code> is an Err the method will return the Err immediately.</p>
<p>To crash a Rust program you should use <code>panic!(&quot;message&quot;)</code>. This will print the message and stacktrace to the command line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-and-nulls"><a class="header" href="#option-and-nulls">Option and nulls</a></h1>
<p><code>Option&lt;T&gt;</code>s are the same as <code>Optional&lt;T&gt;</code>s and quite like nullable values and are created via <code>Some()</code> and <code>None</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; { 
	if denominator == 0.0 {
		None //notice no return and no semicolon 
	} else {
        Some(numerator / denominator)
    } //the last value in a method is automatically returned
} //assuming no return call 

fn main() {
	let result = divide(2.0, 3.0);
	match result {
		Some(x) =&gt; println!(&quot;Result: {}&quot;, x), 
		None =&gt; println!(&quot;Cannot divide by 0&quot;),
	}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-macros"><a class="header" href="#creating-macros">Creating macros</a></h1>
<h2 id="macro-template"><a class="header" href="#macro-template">Macro template</a></h2>
<pre><code class="language-rust  ignore">macro_rules! &lt;name&gt; {
    (&lt;args&gt;) =&gt; {
        &lt;body&gt;
    };
}</code></pre>
<ul>
<li><code>&lt;name&gt;</code> can be any valid rust ident</li>
<li><code>&lt;args&gt;</code> see below</li>
<li><code>&lt;body&gt;</code> see below</li>
</ul>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p>Arguments can be empty, or combinations of variables and variadic.</p>
<p>Each arg must be the format <code>$&lt;name&gt;:&lt;type&gt;</code>. (i.e. <code>$example:literal</code> )</p>
<ul>
<li><code>&lt;name&gt;</code> can be any valid rust ident</li>
<li><code>&lt;type&gt;</code> must be one of</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>literal</td><td>Rust literal, such as a number</td></tr>
<tr><td>block</td><td>Block of code</td></tr>
<tr><td>expr</td><td>A single expression</td></tr>
<tr><td>ty</td><td>Rust type</td></tr>
<tr><td>ident</td><td>Rust ident</td></tr>
<tr><td>and others</td><td></td></tr>
</tbody></table>
</div>
<p>For example, this macro makes methods that adds two numbers:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! add_numbers {
	($method_name:ident, $num_type:ty) =&gt; {
		fn $method_name(lhs: $num_type, rhs: $num_type) -&gt; $num_type {
			lhs + rhs
		}
	}
}
<span class="boring">}</span></code></pre></pre>
<p>When called with <code>add_number(add_i32, i32);</code> this code is generated:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_i32(lhs: i32, rhs: i32) -&gt; i32 {
	lhs + rhs
}
<span class="boring">}</span></code></pre></pre>
<h4 id="variadic"><a class="header" href="#variadic">Variadic</a></h4>
<p>Arguments can be written as <code>$( &lt;arg&gt; )*</code> for 0 or more and <code>$( &lt;arg&gt; )+</code> for 1 or more values. (i.e. <code>$( $name:literal )+</code>), this would allow <code>example!(1 2 3)</code>.</p>
<p>To support commas you can write <code>$( &lt;arg&gt; ),*</code>, this would allow <code>example!(1,2,3)</code>.</p>
<h4 id="optional"><a class="header" href="#optional">Optional</a></h4>
<p>Anything can be optional using this syntax <code>$( &lt;thing&gt; )?</code>, this include commas, such as </p>
<ul>
<li>optional trailing comma: <code>macro_rules! example($var1:literal, $var2:literal $(,)?)</code></li>
<li>optional commas in variadic: <code>macro_rules! list($( $items:literal )$(,)?*)</code></li>
</ul>
<h3 id="body"><a class="header" href="#body">Body</a></h3>
<p>The body must be an expression or single line, to support multiple lines surround the code in {}, this is often written as </p>
<pre><code class="language-rust  ignore">macro_rules! &lt;name&gt; {
    (&lt;args&gt;) =&gt; {{
        &lt;body&gt;
    }};
}</code></pre>
<h4 id="variadic-1"><a class="header" href="#variadic-1">Variadic</a></h4>
<p>To use these arguments you have to surround them in <code>$( &lt;name&gt; )*</code> in the body.
Anything can be written in the parentheses and it will be repeated once per item in <code>&lt;name&gt;</code></p>
<p>For example if you want to print each item on a different line:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! print_nums {
    ($( $numbers:literal ),+) =&gt; {{
        $( println!(&quot;{}&quot;, $numbers); )*
    }};
}
<span class="boring">}</span></code></pre></pre>
<p>If called with <code>print_nums(1,2,3);</code> This generates</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 1);
println!(&quot;{}&quot;, 2);
println!(&quot;{}&quot;, 3);
<span class="boring">}</span></code></pre></pre>
<h4 id="optional-1"><a class="header" href="#optional-1">Optional</a></h4>
<p>Optional arguments should also be surrounded like <code>$( &lt;name&gt; )*</code>, anything can be written inside like before.</p>
<p>When dealing with optional args you may need to get an alternative value</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! add_nums {
    ($num1: expr $(, $num2: expr)?) =&gt; {
        $num1 + $( $num2 )*
    };
}
<span class="boring">}</span></code></pre></pre>
<p>This works fine if called with <code>add_nums!(1,2)</code> but with <code>add_nums!(1)</code> the code generated would be <code>1 + </code> which fails to compile.</p>
<p>To get around this use something to offer a substitute such as</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! some_or_none {
    () =&gt; { None };
    ($entity:expr) =&gt; { Some($entity) }
}

//or

macro_rules! or_else {
    ($value:literal, $other: literal) =&gt; { $value};
    (, $other: literal) =&gt; { $other };
}
<span class="boring">}</span></code></pre></pre>
<p>These are used like this</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! add_nums {
    ($( $num1: expr )? $(, $num2: expr)?) =&gt; {
        or_else!($( $num1 )*, 0) + or_else!($( $num2 )*, 0)
    };
}
<span class="boring">}</span></code></pre></pre>
<h3 id="overloading"><a class="header" href="#overloading">Overloading</a></h3>
<p>Macros can support different argument sets:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! add_nums {
	($num1:literal, $num2:literal) =&gt; { $num1 + $num2 };
	($num1:literal, $num2:literal, $num3:literal) =&gt; { $num1 + $num2 + $num3 };
}
<span class="boring">}</span></code></pre></pre>
<p>This can be called with <code>add_nums!(1,2);</code> and <code>add_nums!(1,2,3);</code></p>
<h3 id="advanced"><a class="header" href="#advanced">Advanced</a></h3>
<p>Macros will accept extra text which can be required to invoke the macro:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! add_nums {
    ($num1: literal + $num2: expr) =&gt; {
        $num1 + $num2
    };
    (($num1: expr) + $num2: expr) =&gt; {
        $num1 + $num2
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Would have be called like this <code>add_nums!(1 + 2)</code> or <code>add_nums!((some_var) + 2)</code></p>
<p>With custom text in the arguments then either commas are needed to separate them 
<code>macro_rules! example($thing1:expr, $thing2:expr)</code> or all but the last expr must be declared and called surrounded by parentheses <code>macro_rules! example(($thing1:expr) $thing2:expr)</code> and <code>example!((thing1) thing2);</code></p>
<p>See more <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macros by example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>To pass values safely between threads you need to use Mutexes or Atomic values in most languages, Rust is no different. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::sync::atomic::{AtomicI8, Ordering};
use std::sync::Arc;
use std::time::Duration;

fn main() {
    //AtomicXX implement Sync meaning they can be used 
    //in multiple threads safely
    //Arc (Atomically Reference Counted) allows for multiple, independent
    //references of a single value to exist outside of the borrow checker
    //for a tiny overhead by counting the number of references that
    //exist
    let number = Arc::new(AtomicI8::new(0i8));
    //Make a copy of the arc, any number of copies can exist but
    //the each copy has to be moved into it's thread
    let thread_number = number.clone();

    //move means this lambda is taking ownership of any variable
    //it uses, this is necessary for lambdas executed in a different
    //context e.g. in a different thread
    thread::spawn(move || {
        let mut i = 0;
        loop {
            //ordering controls how the atomic value is set/read
            //You should probably always use SeqCst
            thread_number.store(i, Ordering::SeqCst);
            i += 1;
            thread::sleep(Duration::from_millis(500));
            if i &gt; 10 {
                break;
            }
        }
        println!(&quot;Done&quot;);
    });

    loop {
        println!(&quot;{}&quot;, number.load(Ordering::SeqCst));
        if number.load(Ordering::SeqCst) &gt;= 10 {
            break;
        }
    }
}</code></pre></pre>
<p>This program will continually print out the value stored in <code>number</code> until the thread reaches 10</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>The standard in Rust is to have the tests in a module inside the module being tested, the test module needs to be annotated as do all the tests:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//foo.rs 

fn add(value1: i32, value2: i32) -&gt; i32 {
  value1 + value2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_all() {
        assert_eq!(2, add(1, 1));
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>To run and build programs from the command line you should always use cargo (outside of an IDE):</p>
<pre><code class="language-bash">#Build debug version
cargo build

#Run debug version
cargo run

#Run tests
cargo test

#Build release version
cargo build --release
</code></pre>
<p>Other command line options:</p>
<pre><code class="language-bash">#Format all code
cargo fmt

#Linter
cargo clippy

#These have to be installed first by
rustup update
rustup component add rustfmt
rustup component add clippy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>To install a tool use <code>cargo install &lt;tool&gt;</code>, for example <code>cargo install cargo-edit</code></p>
<h2 id="dependency-management"><a class="header" href="#dependency-management">Dependency management</a></h2>
<p><strong>Description</strong></p>
<p>Allows you to add, remove or update dependencies from the command line</p>
<p><strong>Usage</strong></p>
<p><code>cargo add &lt;crate&gt;</code>, e.g. <code>cargo add chrono</code></p>
<p><code>cargo rm &lt;crate&gt;</code></p>
<p><code>cargo upgrade</code></p>
<p><strong>Link</strong></p>
<p><a href="https://github.com/killercup/cargo-edit">cargo-edit</a></p>
<h2 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency graph</a></h2>
<p><strong>Description</strong></p>
<p>Generates a dependency graph for your project</p>
<p><strong>Usage</strong></p>
<p><code>cargo deps</code></p>
<p><strong>Link</strong></p>
<p><a href="https://github.com/m-cat/cargo-deps">cargo-deps</a></p>
<h2 id="security-audit"><a class="header" href="#security-audit">Security Audit</a></h2>
<p><strong>Description</strong></p>
<p>Audit Cargo.lock files for crates with security vulnerabilities reported to the RustSec Advisory Database.</p>
<p><strong>Usage</strong></p>
<p><code>cargo audit</code></p>
<p><strong>Install commands</strong></p>
<p><code>cargo install cargo-audit</code></p>
<p><strong>Link</strong></p>
<p><a href="https://github.com/RustSec/cargo-audit">cargo-audit</a></p>
<h2 id="macro-expansion"><a class="header" href="#macro-expansion">Macro Expansion</a></h2>
<p><strong>Description</strong></p>
<p>Prints out the result of macro expansion and <code>#[derive]</code> expansion applied to the current crate.</p>
<p><strong>Usage</strong></p>
<p><code>cargo expand [module]</code></p>
<p><strong>Install commands</strong></p>
<p><code>cargo install cargo-expand</code></p>
<p><strong>Link</strong></p>
<p><a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a></p>
<h2 id="outdated-dependencies"><a class="header" href="#outdated-dependencies">Outdated dependencies</a></h2>
<p><strong>Description</strong></p>
<p>Prints out report of out of date dependencies.</p>
<p><strong>Usage</strong></p>
<p><code>cargo outdated</code></p>
<p><strong>Install commands</strong></p>
<p><code>cargo install cargo-outdated</code></p>
<p><strong>Link</strong></p>
<p><a href="https://github.com/kbknapp/cargo-outdated">cargo-outdated</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Unfortunately enums in Rust work they do in Swift and so no default values can be provided and instead you have to add methods which use matches to provide values:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum MobileOs {
  Android, Ios, Windows
}

impl MobileOs {
  fn status(&amp;self) -&gt; &amp;str {
    match self {
      MobileOs::Android =&gt; return &quot;alive&quot;,
      MobileOs::Ios =&gt; return &quot;alive&quot;,
      MobileOs::Windows =&gt; return &quot;dead&quot;,
    }
  }
}

fn main() {
  println!(&quot;{}&quot;, MobileOs::Android.status());
}</code></pre></pre>
<p>Thankfully they can also work like sealed classes:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Example {
  Foo { named_value: i32 },
  Tuple(u8, u8),
  Empty
}

fn main() {
  let foo = Example::Foo { named_value: 45 };
  let tuple = Example::Tuple(1, 2);
  let empty = Example::Empty;
}</code></pre></pre>
<p>When coming from other modern languages you be expecting the ability to get a variant count, list or names and add static values to each variant but unfortunately Rust enums do not support any of these features, but all of these can be added with the strum crate.</p>
<h3 id="strum"><a class="header" href="#strum">Strum</a></h3>
<p>The <a href="https://github.com/Peternator7/strum">strum crate</a> adds many features to enums on a case by case basis.</p>
<p>It provides:</p>
<ul>
<li>To and from string for enum variants</li>
<li>Variant iterator</li>
<li>Enum count</li>
<li>Property values</li>
<li>etc</li>
</ul>
<p>Each feature needs to be enabled by adding a derive macro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h1>
<p><strong>Minor tips</strong></p>
<p>Reading a line from the command prompt using <code>std::io::stdin().read_line()</code> will include the return character, remove it using <code>trim()</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>Like in Swift an Option can be unwrapped with an if, if there is a value match:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_method(optional_string: Option&lt;String&gt;) {
  if let Some(string_value) = optional_string {
    println!(&quot;Does exist: {}&quot;, string_value);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>This also works for Result but use Ok and Err instead of Some and None. If you need to handle both states you should use match as an if let throws away the other value:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Error = Box&lt;dyn std::error::Error&gt;;
</span>
fn some_method(optional_string: Option&lt;String&gt;) {
  match optional_string {
    Some(string_value) =&gt; println!(&quot;Does exist: {}&quot;, string_value),
    None =&gt; println!(&quot;No content&quot;)
  }
}

fn another_method(result: Result&lt;String, Error&gt;) {
  match result {
    Ok(string_value) =&gt; println!(&quot;Success: {}&quot;, string_value),
    Err(err) =&gt; println!(&quot;Failure: {}&quot;, err)
  }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-counting"><a class="header" href="#reference-counting">Reference counting</a></h1>
<p>Sometimes you need bypass the borrow checker, for example, you want to use a reference as a pointer to an item in a collection or you’re passing values between threads. To do this you use the Arc (Atomically Reference Counted) class, it adds a small overhead in the form of a count and some extra code to monitor and update the count. Arc will keep the value alive as long as any Arc value is still alive, when the last Arc value is dropped the value will be as well. To make multiple references to an value protected by Arc clone it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Arc;

fn main() {
  let some_heap_thing = Thing::new();
  let arc_thing = Arc::new(some_heap_thing);
  thread1(arc_thing.clone()); 
  thread2(arc_thing.clone()); 
}

fn thread1(thing: Arc&lt;Thing&gt;) {
  thing.methods_accessed_in_normal_way();
}

<span class="boring">fn thread2(thing: Arc&lt;Thing&gt;) {}
</span><span class="boring">struct Thing {}
</span><span class="boring">impl Thing { 
</span><span class="boring">fn new() -&gt; Thing {Thing {} } 
</span><span class="boring">fn methods_accessed_in_normal_way(&amp;self) {}
</span><span class="boring">}</span></code></pre></pre>
<p>The value in the Arc can not be mutable unless it’s contained in another class, as the value will need to be protected against concurrent updates, the wrapper types are Mutex and RwLock. The differences are that RwLock will allow any number of concurrent readers but only one writer and Mutex only allows one reader or writer at a time. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-strings"><a class="header" href="#converting-strings">Converting strings</a></h1>
<p>Often when writing a function that takes a piece of text you’ll want to support both <code>String</code> and <code>&amp;str</code> to be more convenient to the caller. This is best achieved by using <code>&amp;str</code> or <code>Into&lt;String&gt;</code>. </p>
<p><code>String</code> can be converted to <code>&amp;str</code> like this:</p>
<pre><code class="language-rust ignore does_not_compile">let text = String::new();
print(&amp;text);</code></pre>
<p>(Actually it's converted to <code>&amp;String</code> as adding a <code>&amp;</code> just makes it a reference but rust treats <code>&amp;String</code> as <code>&amp;str</code> when passed a parameter)</p>
<p>The Into trait tells the compiler to allow any parameter that be coerced as that type to be passed in. <code>&amp;str</code> already has the <code>Into&lt;String&gt;</code> trait but it can also be implemented for any struct. <code>Into&lt;X&gt;</code> for Y is automatically implemented for any type that implements <code>From&lt;Y&gt;</code> for X which is actually how it’s implemented for Strings and is the recommended approach. </p>
<pre><code class="language-rust ignore does_not_compile">fn print(value: &amp;str) { 
	println!(&quot;{}&quot;, value;
}

fn print&lt;S: Into&lt;String&gt;&gt;(value: S) { 
	println!(&quot;{}&quot;, value.into());
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interior-mutability"><a class="header" href="#interior-mutability">Interior mutability</a></h1>
<p>Sometimes you need to have a mutable value but can only pass it around as a value or reference, to achieve you can use the <code>Cell</code> structs.</p>
<p><code>Cell</code> is a wrapper around a value that can be changed at any point.</p>
<p><code>RefCell</code> is the same as <code>Cell</code> but allows the value to be exposed as a reference.</p>
<p><code>RwLock</code> is the same as <code>RefCell</code> but can be shared across threads.</p>
<p><code>Mutex</code> is the same as <code>RefCell</code> but can make references that can be shared across threads. </p>
<p>All of these are safe, they use reference counting and/or memory swapping to update values.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span>
fn main() {
    let not_mutable = Person {
        name: RefCell::new(String::from(&quot;Ray Britton&quot;))
    };

    not_mutable.change_name(String::from(&quot;New Name&quot;));

    println!(&quot;{}&quot;, not_mutable.name.borrow());
}

struct Person {
    name: RefCell&lt;String&gt;
}

impl Person {
    fn change_name(&amp;self, new_name: String) {
        self.name.replace(new_name);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexed-iteration"><a class="header" href="#indexed-iteration">Indexed iteration</a></h1>
<p>Kotlin provides forEach, map, filter, etc for iterators but these only give you the element if you also need the index as Kotlin provides forEachIndexed, mapIndexed, filterIndexed, etc</p>
<pre><code class="language-kotlin">list.forEach { element -&gt;
	println(element)
}
list.forEachIndexed { i, element -&gt; 
	println(&quot;${i}: ${element}&quot;)
} 
</code></pre>
<p>Rust also has this feature but it works differently, instead of different methods the iterator type is changed via enumerate:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let list = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
</span>list.iter()
	.for_each(|element| println!(&quot;{}&quot;, element));

list.iter()
	.enumerate()
	.for_each(|(i, element)| println!(&quot;{}: {}&quot;, i, element));
<span class="boring">}</span></code></pre></pre>
<p>This has the downside that all later operators must also handle the index as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatting-strings"><a class="header" href="#formatting-strings">Formatting strings</a></h1>
<p>To format a string, the easiest (and correct) way is to use <code>format!(string, parameters...)</code>. String formatting in Rust uses {} as placeholders for parameters.</p>
<p>Basics:</p>
<p><code>&quot;{}&quot;</code> will print the result of Display::fmt(), this must be manually implemented &quot;{:?}&quot; will print the result of Debug::fmt(), this can be derived</p>
<p><code>&quot;{:#?}&quot;</code> will pretty print the result of Debug::fmt()</p>
<p><code>&quot;{example}&quot;</code> will print parameter named example</p>
<p><code>&quot;{2}&quot;</code> will print the third parameter</p>
<p>Padding:</p>
<p><code>&quot;{:&gt;5}&quot;</code> Left pad with up to 5 spaces</p>
<p><code>&quot;{:&lt;7}&quot;</code> Right pad with up to 7 spaces</p>
<p><code>&quot;{:^22}&quot;</code> Centre with up to 11 spaces on both sides</p>
<p>Padding with any character:</p>
<p><code>&quot;{:_&gt;5}&quot;</code> Left pad with up to 5 underscores </p>
<p><code>&quot;{:#&lt;7}&quot;</code> Right pad with up to 7 hashes </p>
<p><code>&quot;{:c^22}&quot;</code> Centre with up to 11 ’c’s on both sides</p>
<p>Numbers:</p>
<p><code>&quot;{:.3}&quot;</code> Will print 3 fractional digits (adding 0s on the end if necessary) but only if it’s a floating point number</p>
<p><code>&quot;{:+3}&quot;</code> Print sign</p>
<p><code>&quot;{:03}&quot;</code> Print at least 3 digits (padding with 0s on the start if necessary), if negative the minus symbol will replace a 0</p>
<p>Example: <code>format!(&quot;{:&gt;5} {named}&quot;, &quot;Foo&quot;, named=123)</code></p>
<p>To have variable parts (such as variable length padding) use this syntax:</p>
<p><code>(&quot;{1:.0$}&quot;, 1, 1.22)</code></p>
<p>This will print 1.2, the syntax is <code>{value_index:.precision_index$}</code></p>
<p><code>(&quot;{1:=&lt;0$}&quot;, 10, &quot;test&quot;)</code></p>
<p>This will print test======, the syntax is <code>{value_index:padding_char&lt;length_index$}</code></p>
<p>Note that invalid parameter details are ignored silently and treated as {}. If debugging via logging consider using dgb!():</p>
<pre><code class="language-rust ignore">let x;
x = dbg!(1 * 4); </code></pre>
<p>prints
<code>[src/main.rs:3] 1 * 4 = 4</code></p>
<h1 id="direct-variable-usage"><a class="header" href="#direct-variable-usage">Direct variable usage</a></h1>
<p>As of Rust <code>1.58.0</code> and edition <code>2021</code> you can use variables name in the string directly:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let part = &quot;world&quot;;
println!(&quot;Hello {part}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Unforutantely this doesn't support complex expressions yet, so you can't do:</p>
<pre><code class="language-rust ignore">println!(&quot;{some_method()}&quot;);</code></pre>
<p>or</p>
<pre><code class="language-rust ignore">println!(&quot;{struct.field}&quot;);</code></pre>
<p>This should work with any macro that uses <code>format_args</code> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-crates"><a class="header" href="#for-crates">For crates</a></h1>
<h2 id="date-formatting"><a class="header" href="#date-formatting">Date Formatting</a></h2>
<h3 id="chrono"><a class="header" href="#chrono">Chrono</a></h3>
<p>Using <code>DateTimeFormat.forPattern(&quot;&lt;pattern&gt;&quot;).print(DateTime.now())</code> for Kotlin and <code>Utc::now().format(&quot;&lt;pattern&gt;&quot;)</code> for Rust.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Kotlin/JodaTime</th><th>Rust/Chrono</th><th>Example</th></tr></thead><tbody>
<tr><td>Date</td><td><code>yyyy-MM-dd</code></td><td><code>%Y-%M-%D</code></td><td>2000-01-01</td></tr>
<tr><td>Text Date</td><td><code>dd MMM yyyy</code></td><td><code>%e %b %Y</code></td><td>15 Jun 2004</td></tr>
<tr><td>Time</td><td><code>HH:mm:ss</code></td><td><code>%H:%M:%S</code></td><td>14:12:56</td></tr>
<tr><td>to ISO 8601</td><td><code>DateTime.now().toString()</code></td><td><code>Utc::now().to_rfc3339_opts( SecondsFormat::Millis, true)</code></td><td>1996-12-19T16:39:57.000Z</td></tr>
<tr><td>from ISO 8601</td><td><code>DateTime.parse</code></td><td><code>Utc::parse_from_rfc_3339</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="json-parsing"><a class="header" href="#json-parsing">JSON Parsing</a></h2>
<h3 id="serde"><a class="header" href="#serde">Serde</a></h3>
<p>Add this to <code>cargo.toml</code>:</p>
<pre><code class="language-toml">serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">data class Example(
    val name: String,
    @SerializedName(&quot;num&quot;)
    val someNumber: Int
)

fun convert(json: String, example: Example) {
    val outputExample: Example = Gson().fromJson&lt;Example&gt;(json, Example::class.java)
    val outputJson: String = Gson().toJson(example)
}
</code></pre>
<p><strong>Rust</strong></p>
<pre><code class="language-rust ignore">#[derive(Serialize,Deserialize)]
struct Example {
    name: String,
    #[serde(rename = &quot;num&quot;)]
    some_number: i32
}

fn convert(json: String, example: Example) {
    let output_example: Example = serde_json::from_str(&amp;json).unwrap();
    let output_json: String = serde_json::to_string(&amp;example).unwrap();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-bugsissues"><a class="header" href="#common-bugsissues">Common bugs/issues</a></h1>
<h3 id="cloning-a-reference-returns-a-reference-despite-the-signature-being-a-value"><a class="header" href="#cloning-a-reference-returns-a-reference-despite-the-signature-being-a-value">Cloning a reference returns a reference despite the signature being a value</a></h3>
<p>This can because the struct doesn’t implement/derive <code>Clone</code></p>
<h3 id="cannot-move-out-of-borrowed-content-when-using-unwrap"><a class="header" href="#cannot-move-out-of-borrowed-content-when-using-unwrap">cannot move out of borrowed content when using unwrap()</a></h3>
<p>This is because <code>unwrap()</code> consumes the reference (it’s self parameter is just <code>self</code>), to fix this use <code>variable.as_ref().unwrap()</code>.</p>
<h3 id="no-method-named--found-for-rcrefcell"><a class="header" href="#no-method-named--found-for-rcrefcell">No method named <code>..</code> found for Rc&lt;RefCell<X>&gt;</a></h3>
<p>Most likely you have imported <code>use std::borrow::BorrowMut</code>, remove it.
The error is caused because there are two methods named <code>borrow_mut</code> and importing the trait causes the wrong one to be called. See <a href="https://github.com/rust-lang/rust/issues/39232">GitHub issue</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Kotlin is an object orientated language which means that generally data and methods are grouped together in classes and it’s very rare to have methods outside of classes even though Kotlin fully supports this. Also classes can extend each other so a lot of frameworks (such as Android or AWT) rely heavily on inheritance to provide functionality to classes.</p>
<p>Rust is a data orientated language, and programs will more resemble C programs where a program may be made of a few methods and a few structs without any impls. And as impl inheritance is impossible in Rust and trait inheritance doesn’t really add much use, composition is used a lot.</p>
<p>That said grouping logic and data is still fine and done with Rust:</p>
<pre><code class="language-kotlin">class Point( 
	val x: Float, 
	val y: Float
){
	fun distanceTo(other: Point): Float {...}
	fun angleTo(other: Point): Float {...} 
}
</code></pre>
<p>can become</p>
<pre><code class="language-rust ignore">struct Point {
	x: f32,
	y: f32 
}

impl Point {
	fn new(x: f32, y: f32) -&gt; Point {
		return Point {x, y}; 
	}
}

impl Point {
	fn distance_to(other: Point) -&gt; f32 {...}
	fn angle_to(other: Point) -&gt; f32 {...} 
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h2>
<p><a href="https://rust-unofficial.github.io/too-many-lists">Linked List</a>
An in depth guide on how to implement a linked list in Rust</p>
<p><a href="https://github.com/sunjay/tic-tac-toe">Tic-Tac-Toe</a>
This project is heavily commented and is an example of idiomatic and well written Rust.</p>
<p><a href="https://bitbucket.org/raybritton/kotlin-rust-comparison">Language Comparison</a>
These both contain files with the common patterns (constants, lambdas, etc) implemented in both languages were possible, they are coded in the correct style for their respective languages</p>
<p><a href="https://github.com/raybritton/rosetta-roman-numerals">Roman Numerals</a>
This contains CLI programs created in multiple languages that converts Roman numerals into decimal numbers and vice versa, the programs have the same methods, tests and functionality</p>
<h2 id="rust-community"><a class="header" href="#rust-community">Rust Community</a></h2>
<p><a href="https://www.reddit.com/r/rust">Official subreddit</a></p>
<p><a href="https://www.reddit.com/r/learnrust">Subreddit for beginners</a></p>
<p><a href="https://discord.gg/rust-lang">Discord</a></p>
<p><a href="https://this-week-in-rust.org">Weekly newsletter</a></p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p><a href="https://doc.rust-lang.org/stable/reference">Language reference</a></p>
<p><a href="https://doc.rust-lang.org/stable/edition-guide/rust-2018">Guide for changes in 2018 edition of Rust</a> (This should only be needed for converting old code)</p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p><a href="https://play.rust-lang.org">Playground</a></p>
<p><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html">Rust: A Unique Perspective</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
